#include <immintrin.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

uint16_t bases[256] = {
    0x3ce7, 0x07e2, 0x00a6, 0x1d05, 0x1f80, 0x3ead, 0x2907, 0x112f, 0x079d,
    0x050f, 0x0ad8, 0x0e24, 0x0230, 0x0c38, 0x145c, 0x0a61, 0x08fc, 0x07e5,
    0x122c, 0x05bf, 0x2478, 0x0fb2, 0x095e, 0x4fee, 0x2825, 0x1f5c, 0x08a5,
    0x184b, 0x026c, 0x0eb3, 0x12f4, 0x1394, 0x0c71, 0x0535, 0x1853, 0x14b2,
    0x0432, 0x0957, 0x13f9, 0x1b95, 0x0323, 0x04f5, 0x0f23, 0x01a6, 0x02ef,
    0x0244, 0x1279, 0x27ff, 0x02ea, 0x0b87, 0x022c, 0x089e, 0x0ec2, 0x01e1,
    0x05f2, 0x0d94, 0x01e1, 0x09b7, 0x0cc2, 0x1601, 0x01e8, 0x0d2d, 0x1929,
    0x0d10, 0x0011, 0x3b01, 0x05d2, 0x103a, 0x07f4, 0x075a, 0x0715, 0x01d3,
    0x0ceb, 0x36da, 0x18e3, 0x0292, 0x03ed, 0x0387, 0x02e1, 0x075f, 0x1d17,
    0x0760, 0x0b20, 0x06f8, 0x1d87, 0x0d48, 0x03b7, 0x3691, 0x10d0, 0x00b1,
    0x0029, 0x4da3, 0x0c26, 0x33a5, 0x2216, 0x023b, 0x1b83, 0x1b1f, 0x04af,
    0x0160, 0x1923, 0x00a5, 0x0491, 0x0cf3, 0x03d2, 0x00e9, 0x0bbb, 0x0a02,
    0x0bb2, 0x295b, 0x272e, 0x0949, 0x076e, 0x14ea, 0x115f, 0x0613, 0x0107,
    0x6993, 0x08eb, 0x0131, 0x029d, 0x0778, 0x0259, 0x182a, 0x01ad, 0x078a,
    0x3a19, 0x06f8, 0x067d, 0x020c, 0x0df9, 0x00ec, 0x0938, 0x1802, 0x0b22,
    0xd955, 0x06d9, 0x1052, 0x2112, 0x00de, 0x0a13, 0x0ab7, 0x07ef, 0x08b2,
    0x08e4, 0x0176, 0x0854, 0x032d, 0x5cec, 0x064a, 0x1146, 0x1427, 0x06bd,
    0x0e0d, 0x0d26, 0x3800, 0x0243, 0x00a5, 0x055f, 0x2722, 0x3148, 0x2658,
    0x055b, 0x0218, 0x074b, 0x2a70, 0x0359, 0x089e, 0x169c, 0x01b2, 0x1f95,
    0x44d2, 0x02d7, 0x0e37, 0x063b, 0x1350, 0x0851, 0x07ed, 0x2003, 0x2098,
    0x1858, 0x23df, 0x1fbe, 0x074e, 0x0ce0, 0x1d1f, 0x22f3, 0x61b9, 0x021d,
    0x4aab, 0x0170, 0x0236, 0x162a, 0x019b, 0x020a, 0x0403, 0x2017, 0x0802,
    0x1990, 0x2741, 0x0266, 0x0306, 0x091d, 0x0bbf, 0x8981, 0x1262, 0x0480,
    0x06f9, 0x0404, 0x0604, 0x0e9f, 0x01ed, 0x117a, 0x09d9, 0x68dd, 0x20a2,
    0x0360, 0x49e3, 0x1559, 0x098f, 0x002a, 0x119f, 0x067c, 0x00a6, 0x04e1,
    0x1873, 0x09f9, 0x0130, 0x0110, 0x1c76, 0x0049, 0x199a, 0x0383, 0x0b00,
    0x144d, 0x3412, 0x1b8e, 0x0b02, 0x0c7f, 0x032b, 0x039a, 0x015e, 0x1d5a,
    0x1164, 0x0d79, 0x0a67, 0x1264, 0x01a2, 0x0655, 0x0493, 0x0d8f, 0x0058,
    0x2c51, 0x019c, 0x0617, 0x00c2,
};

// deterministic miller-rabin test using only
// one base generated from a hash table

int prime(int n) {
  // check small primes
  int p[4] = {2, 3, 5, 7};

  for (int i = 0; i < 4; i++) {
    if (n == p[i])
      return 1;
    if (!(n % p[i]))
      return 0;
  }

  // eliminate small values of n
  if (n < 121) {
    return n > 1;
  }

  // generate hash of n, to get the base
  uint64_t h = n, v = 1;
  h = ((h >> 16) ^ h) * 0x45d9f3b;
  h = ((h >> 16) ^ h) * 0x45d9f3b;
  h = ((h >> 16) ^ h) & 0xff;
  h = bases[h];

  // perform a single determininstic
  // round of miller_rabin test
  // n = d * 2^s + 1
  int s = _tzcnt_u32(n - 1), d = (n - 1) >> s;

  // compute v = h^d (mod n)
  for (; d; d >>= 1) {
    if (d & 1)
      v = v * h % n;
    h = h * h % n;
  }

  if (v == 1) {
    return 1;
  }

  for (int r = 0; r < s; r++) {
    if (v == n - 1) {
      return 1;
    }
    v = v * v % n;
  }

  return 0;
}

// Binary GCD (or Stein's) algorithm
// using Intel BMI intrinsics

int gcd(int u, int v) {
  if (u == 0)
    return v;
  if (v == 0)
    return u;

  int shift = _tzcnt_u32(u | v);
  u >>= _tzcnt_u32(u);

  while (v) {
    v >>= _tzcnt_u32(v);
    v -= u;
    u += v & -(v < 0);
    v = abs(v);
  }

  return u << shift;
}

// Pollard Rho Algorithm using Brent's cycle
// detection algorithm, and using backtracking
// to omit unecessary GCD computations

int pollard_rho(int n) {
  int x = 2, q = 1;

  for (int r = 1;; r <<= 1) {
    int y = x, g;

    for (int i = 0; i < r; i++) {
      x = ((uint64_t)x * x + 3) % n;
      q = (uint64_t)q * abs(x - y) % n;
    }

    if ((g = gcd(q, n)) != 1) {
      for (x = y; g == 1 || g == n;) {
        x = ((uint64_t)x * x + 3) % n;
        g = gcd(abs(x - y), n);
      }
      return g;
    }
  }

  return n;
}

// factor n by removing trivial factors, and then
// using pollard rho for non-trivial factors

void factor(int n) {
  printf("%d: ", n);
  clock_t t = clock();

  // remove factors of 2
  int zeros = _tzcnt_u32(n);
  n >>= zeros;

  for (int i = 0; i < zeros; i++) {
    printf("2 ");
  }

  // remove all other trivial factors
  for (int i = 3; i < 1024 && n != 1; i += 2) {
    while (!(n % i)) {
      printf("%d ", i);
      n /= i;
    }
  }

  // find non-trivial factors
  while (n != 1 && !prime(n)) {
    int i = pollard_rho(n);
    printf("%d ", i);
    n /= i;
  }

  // print last prime factor
  if (n != 1) {
    printf("%d ", n);
  }

  t = clock() - t;
  printf("\n(%ldÎ¼s)\n", t);
}

int main(int argc, char **argv) {
  for (int i = 1; i < argc; i++) {
    int n = strtol(argv[i], NULL, 10);
    factor(n);
  }
}
